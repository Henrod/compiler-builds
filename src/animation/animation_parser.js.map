{"version":3,"sources":["../../../../../modules/@angular/compiler/src/animation/animation_parser.ts"],"names":[],"mappings":"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","file":"animation_parser.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileAnimationAnimateMetadata, CompileAnimationEntryMetadata, CompileAnimationGroupMetadata, CompileAnimationKeyframesSequenceMetadata, CompileAnimationMetadata, CompileAnimationSequenceMetadata, CompileAnimationStateDeclarationMetadata, CompileAnimationStateTransitionMetadata, CompileAnimationStyleMetadata, CompileAnimationWithStepsMetadata, CompileDirectiveMetadata, identifierName} from '../compile_metadata';\nimport {StringMapWrapper} from '../facade/collection';\nimport {isBlank, isPresent} from '../facade/lang';\nimport {CompilerInjectable} from '../injectable';\nimport {ParseError} from '../parse_util';\nimport {ANY_STATE, FILL_STYLE_FLAG} from '../private_import_core';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\n\nimport {AnimationAst, AnimationEntryAst, AnimationGroupAst, AnimationKeyframeAst, AnimationSequenceAst, AnimationStateDeclarationAst, AnimationStateTransitionAst, AnimationStateTransitionExpression, AnimationStateTransitionFnExpression, AnimationStepAst, AnimationStylesAst, AnimationWithStepsAst} from './animation_ast';\nimport {StylesCollection} from './styles_collection';\n\nconst /** @type {?} */ _INITIAL_KEYFRAME = 0;\nconst /** @type {?} */ _TERMINAL_KEYFRAME = 1;\nconst /** @type {?} */ _ONE_SECOND = 1000;\n\ndeclare type Styles = {\n  [key: string]: string | number\n};\nexport class AnimationParseError extends ParseError {\n/**\n * @param {?} message\n */\nconstructor(message: string) { super(null, message); }\n/**\n * @return {?}\n */\ntoString(): string { return `${this.msg}`; }\n}\nexport class AnimationEntryParseResult {\n/**\n * @param {?} ast\n * @param {?} errors\n */\nconstructor(public ast: AnimationEntryAst,\npublic errors: AnimationParseError[]) {}\n}\n\nfunction AnimationEntryParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationEntryParseResult.prototype.ast;\n/** @type {?} */\nAnimationEntryParseResult.prototype.errors;\n}\n\n@CompilerInjectable()\nexport class AnimationParser {\n/**\n * @param {?} _schema\n */\nconstructor(private _schema: ElementSchemaRegistry) {}\n/**\n * @param {?} component\n * @return {?}\n */\nparseComponent(component: CompileDirectiveMetadata): AnimationEntryAst[] {\n    const /** @type {?} */ errors: string[] = [];\n    const /** @type {?} */ componentName = identifierName(component.type);\n    const /** @type {?} */ animationTriggerNames = new Set<string>();\n    const /** @type {?} */ asts = component.template.animations.map(entry => {\n      const /** @type {?} */ result = this.parseEntry(entry);\n      const /** @type {?} */ ast = result.ast;\n      const /** @type {?} */ triggerName = ast.name;\n      if (animationTriggerNames.has(triggerName)) {\n        result.errors.push(new AnimationParseError(\n            `The animation trigger \"${triggerName}\" has already been registered for the ${componentName} component`));\n      } else {\n        animationTriggerNames.add(triggerName);\n      }\n      if (result.errors.length > 0) {\n        let /** @type {?} */ errorMessage =\n            `- Unable to parse the animation sequence for \"${triggerName}\" on the ${componentName} component due to the following errors:`;\n        result.errors.forEach(\n            (error: AnimationParseError) => { errorMessage += '\\n-- ' + error.msg; });\n        errors.push(errorMessage);\n      }\n      return ast;\n    });\n\n    if (errors.length > 0) {\n      const /** @type {?} */ errorString = errors.join('\\n');\n      throw new Error(`Animation parse errors:\\n${errorString}`);\n    }\n\n    return asts;\n  }\n/**\n * @param {?} entry\n * @return {?}\n */\nparseEntry(entry: CompileAnimationEntryMetadata): AnimationEntryParseResult {\n    const /** @type {?} */ errors: AnimationParseError[] = [];\n    const /** @type {?} */ stateStyles: {[key: string]: AnimationStylesAst} = {};\n    const /** @type {?} */ transitions: CompileAnimationStateTransitionMetadata[] = [];\n\n    const /** @type {?} */ stateDeclarationAsts: AnimationStateDeclarationAst[] = [];\n    entry.definitions.forEach(def => {\n      if (def instanceof CompileAnimationStateDeclarationMetadata) {\n        _parseAnimationDeclarationStates(def, this._schema, errors).forEach(ast => {\n          stateDeclarationAsts.push(ast);\n          stateStyles[ast.stateName] = ast.styles;\n        });\n      } else {\n        transitions.push( /** @type {?} */((<CompileAnimationStateTransitionMetadata>def)));\n      }\n    });\n\n    const /** @type {?} */ stateTransitionAsts = transitions.map(\n        transDef => _parseAnimationStateTransition(transDef, stateStyles, this._schema, errors));\n\n    const /** @type {?} */ ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);\n    return new AnimationEntryParseResult(ast, errors);\n  }\n}\n\nfunction AnimationParser_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationParser.prototype._schema;\n}\n\n/**\n * @param {?} stateMetadata\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationDeclarationStates(\n    stateMetadata: CompileAnimationStateDeclarationMetadata, schema: ElementSchemaRegistry,\n    errors: AnimationParseError[]): AnimationStateDeclarationAst[] {\n  const /** @type {?} */ normalizedStyles = _normalizeStyleMetadata(stateMetadata.styles, {}, schema, errors, false);\n  const /** @type {?} */ defStyles = new AnimationStylesAst(normalizedStyles);\n  const /** @type {?} */ states = stateMetadata.stateNameExpr.split(/\\s*,\\s*/);\n  return states.map(state => new AnimationStateDeclarationAst(state, defStyles));\n}\n/**\n * @param {?} transitionStateMetadata\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationStateTransition(\n    transitionStateMetadata: CompileAnimationStateTransitionMetadata,\n    stateStyles: {[key: string]: AnimationStylesAst}, schema: ElementSchemaRegistry,\n    errors: AnimationParseError[]): AnimationStateTransitionAst {\n  const /** @type {?} */ styles = new StylesCollection();\n  const /** @type {?} */ transitionExprs: AnimationStateTransitionExpression[] = [];\n  const /** @type {?} */ stateChangeExpr = transitionStateMetadata.stateChangeExpr;\n  const /** @type {?} */ transitionStates: Array<Function|StaticSymbol|string> = typeof stateChangeExpr == 'string' ?\n      ( /** @type {?} */((<string>stateChangeExpr))).split(/\\s*,\\s*/) :\n      [ /** @type {?} */((<Function|StaticSymbol>stateChangeExpr))];\n  transitionStates.forEach(\n      expr => transitionExprs.push(..._parseAnimationTransitionExpr(expr, errors)));\n  const /** @type {?} */ entry = _normalizeAnimationEntry(transitionStateMetadata.steps);\n  const /** @type {?} */ animation = _normalizeStyleSteps(entry, stateStyles, schema, errors);\n  const /** @type {?} */ animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);\n  if (errors.length == 0) {\n    _fillAnimationAstStartingKeyframes(animationAst, styles, errors);\n  }\n\n  const /** @type {?} */ stepsAst: AnimationWithStepsAst = (animationAst instanceof AnimationWithStepsAst) ?\n      animationAst :\n      new AnimationSequenceAst([animationAst]);\n\n  return new AnimationStateTransitionAst(transitionExprs, stepsAst);\n}\n/**\n * @param {?} alias\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationAlias(alias: string, errors: AnimationParseError[]): string {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    default:\n      errors.push(\n          new AnimationParseError(`the transition alias value \"${alias}\" is not supported`));\n      return '* => *';\n  }\n}\n/**\n * @param {?} transitionValue\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationTransitionExpr(\n    transitionValue: string | Function | StaticSymbol,\n    errors: AnimationParseError[]): AnimationStateTransitionExpression[] {\n  const /** @type {?} */ expressions: AnimationStateTransitionExpression[] = [];\n  if (typeof transitionValue == 'string') {\n    let /** @type {?} */ eventStr = /** @type {?} */(( <string>transitionValue));\n    if (eventStr[0] == ':') {\n      eventStr = _parseAnimationAlias(eventStr, errors);\n    }\n    const /** @type {?} */ match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n    if (!isPresent(match) || match.length < 4) {\n      errors.push(new AnimationParseError(`the provided ${eventStr} is not of a supported format`));\n      return expressions;\n    }\n\n    const /** @type {?} */ fromState = match[1];\n    const /** @type {?} */ separator = match[2];\n    const /** @type {?} */ toState = match[3];\n    expressions.push(new AnimationStateTransitionExpression(fromState, toState));\n\n    const /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n    if (separator[0] == '<' && !isFullAnyStateExpr) {\n      expressions.push(new AnimationStateTransitionExpression(toState, fromState));\n    }\n  } else {\n    expressions.push(\n        new AnimationStateTransitionFnExpression( /** @type {?} */((<Function|StaticSymbol>transitionValue))));\n  }\n  return expressions;\n}\n/**\n * @param {?} entry\n * @return {?}\n */\nfunction _normalizeAnimationEntry(entry: CompileAnimationMetadata | CompileAnimationMetadata[]):\n    CompileAnimationMetadata {\n  return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @param {?} permitStateReferences\n * @return {?}\n */\nfunction _normalizeStyleMetadata(\n    entry: CompileAnimationStyleMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[],\n    permitStateReferences: boolean): {[key: string]: string | number}[] {\n  const /** @type {?} */ offset = entry.offset;\n  if (offset > 1 || offset < 0) {\n    errors.push(new AnimationParseError(`Offset values for animations must be between 0 and 1`));\n  }\n\n  const /** @type {?} */ normalizedStyles: {[key: string]: string | number}[] = [];\n  entry.styles.forEach(styleEntry => {\n    if (typeof styleEntry === 'string') {\n      if (permitStateReferences) {\n        normalizedStyles.push(..._resolveStylesFromState( /** @type {?} */((<string>styleEntry)), stateStyles, errors));\n      } else {\n        errors.push(new AnimationParseError(\n            `State based animations cannot contain references to other states`));\n      }\n    } else {\n      const /** @type {?} */ stylesObj = /** @type {?} */(( <Styles>styleEntry));\n      const /** @type {?} */ normalizedStylesObj: Styles = {};\n      Object.keys(stylesObj).forEach(propName => {\n        const /** @type {?} */ normalizedProp = schema.normalizeAnimationStyleProperty(propName);\n        const /** @type {?} */ normalizedOutput =\n            schema.normalizeAnimationStyleValue(normalizedProp, propName, stylesObj[propName]);\n        const /** @type {?} */ normalizationError = normalizedOutput['error'];\n        if (normalizationError) {\n          errors.push(new AnimationParseError(normalizationError));\n        }\n        normalizedStylesObj[normalizedProp] = normalizedOutput['value'];\n      });\n      normalizedStyles.push(normalizedStylesObj);\n    }\n  });\n  return normalizedStyles;\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _normalizeStyleSteps(\n    entry: CompileAnimationMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[]): CompileAnimationMetadata {\n  const /** @type {?} */ steps = _normalizeStyleStepEntry(entry, stateStyles, schema, errors);\n  return (entry instanceof CompileAnimationGroupMetadata) ?\n      new CompileAnimationGroupMetadata(steps) :\n      new CompileAnimationSequenceMetadata(steps);\n}\n/**\n * @param {?} stylesList\n * @param {?} newItem\n * @return {?}\n */\nfunction _mergeAnimationStyles(\n    stylesList: any[], newItem: {[key: string]: string | number} | string) {\n  if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {\n    const /** @type {?} */ lastIndex = stylesList.length - 1;\n    const /** @type {?} */ lastItem = stylesList[lastIndex];\n    if (typeof lastItem === 'object' && lastItem !== null) {\n      stylesList[lastIndex] = StringMapWrapper.merge( /** @type {?} */((\n          <{[key: string]: string | number}>lastItem)), /** @type {?} */(( <{[key: string]: string | number}>newItem)));\n      return;\n    }\n  }\n  stylesList.push(newItem);\n}\n/**\n * @param {?} entry\n * @param {?} stateStyles\n * @param {?} schema\n * @param {?} errors\n * @return {?}\n */\nfunction _normalizeStyleStepEntry(\n    entry: CompileAnimationMetadata, stateStyles: {[key: string]: AnimationStylesAst},\n    schema: ElementSchemaRegistry, errors: AnimationParseError[]): CompileAnimationMetadata[] {\n  let /** @type {?} */ steps: CompileAnimationMetadata[];\n  if (entry instanceof CompileAnimationWithStepsMetadata) {\n    steps = entry.steps;\n  } else {\n    return [entry];\n  }\n\n  const /** @type {?} */ newSteps: CompileAnimationMetadata[] = [];\n  let /** @type {?} */ combinedStyles: Styles[];\n  steps.forEach(step => {\n    if (step instanceof CompileAnimationStyleMetadata) {\n      // this occurs when a style step is followed by a previous style step\n      // or when the first style step is run. We want to concatenate all subsequent\n      // style steps together into a single style step such that we have the correct\n      // starting keyframe data to pass into the animation player.\n      if (!isPresent(combinedStyles)) {\n        combinedStyles = [];\n      }\n      _normalizeStyleMetadata( /** @type {?} */((\n          <CompileAnimationStyleMetadata>step)), stateStyles, schema, errors, true)\n          .forEach(entry => { _mergeAnimationStyles(combinedStyles, entry); });\n    } else {\n      // it is important that we create a metadata entry of the combined styles\n      // before we go on an process the animate, sequence or group metadata steps.\n      // This will ensure that the AST will have the previous styles painted on\n      // screen before any further animations that use the styles take place.\n      if (isPresent(combinedStyles)) {\n        newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n        combinedStyles = null;\n      }\n\n      if (step instanceof CompileAnimationAnimateMetadata) {\n        // we do not recurse into CompileAnimationAnimateMetadata since\n        // those style steps are not going to be squashed\n        const /** @type {?} */ animateStyleValue = ( /** @type {?} */((<CompileAnimationAnimateMetadata>step))).styles;\n        if (animateStyleValue instanceof CompileAnimationStyleMetadata) {\n          animateStyleValue.styles =\n              _normalizeStyleMetadata(animateStyleValue, stateStyles, schema, errors, true);\n        } else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {\n          animateStyleValue.steps.forEach(step => {\n            step.styles = _normalizeStyleMetadata(step, stateStyles, schema, errors, true);\n          });\n        }\n      } else if (step instanceof CompileAnimationWithStepsMetadata) {\n        const /** @type {?} */ innerSteps = _normalizeStyleStepEntry(step, stateStyles, schema, errors);\n        step = step instanceof CompileAnimationGroupMetadata ?\n            new CompileAnimationGroupMetadata(innerSteps) :\n            new CompileAnimationSequenceMetadata(innerSteps);\n      }\n\n      newSteps.push(step);\n    }\n  });\n\n  // this happens when only styles were animated within the sequence\n  if (isPresent(combinedStyles)) {\n    newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n  }\n\n  return newSteps;\n}\n/**\n * @param {?} stateName\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _resolveStylesFromState(\n    stateName: string, stateStyles: {[key: string]: AnimationStylesAst},\n    errors: AnimationParseError[]) {\n  const /** @type {?} */ styles: Styles[] = [];\n  if (stateName[0] != ':') {\n    errors.push(new AnimationParseError(`Animation states via styles must be prefixed with a \":\"`));\n  } else {\n    const /** @type {?} */ normalizedStateName = stateName.substring(1);\n    const /** @type {?} */ value = stateStyles[normalizedStateName];\n    if (!isPresent(value)) {\n      errors.push(new AnimationParseError(\n          `Unable to apply styles due to missing a state: \"${normalizedStateName}\"`));\n    } else {\n      value.styles.forEach(stylesEntry => {\n        if (typeof stylesEntry === 'object' && stylesEntry !== null) {\n          styles.push( /** @type {?} */((stylesEntry as Styles)));\n        }\n      });\n    }\n  }\n  return styles;\n}\nclass _AnimationTimings {\n/**\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n */\nconstructor(public duration: number,\npublic delay: number,\npublic easing: string) {}\n}\n\nfunction _AnimationTimings_tsickle_Closure_declarations() {\n/** @type {?} */\n_AnimationTimings.prototype.duration;\n/** @type {?} */\n_AnimationTimings.prototype.delay;\n/** @type {?} */\n_AnimationTimings.prototype.easing;\n}\n\n/**\n * @param {?} keyframeSequence\n * @param {?} currentTime\n * @param {?} collectedStyles\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _parseAnimationKeyframes(\n    keyframeSequence: CompileAnimationKeyframesSequenceMetadata, currentTime: number,\n    collectedStyles: StylesCollection, stateStyles: {[key: string]: AnimationStylesAst},\n    errors: AnimationParseError[]): AnimationKeyframeAst[] {\n  const /** @type {?} */ totalEntries = keyframeSequence.steps.length;\n  let /** @type {?} */ totalOffsets = 0;\n  keyframeSequence.steps.forEach(step => totalOffsets += (isPresent(step.offset) ? 1 : 0));\n\n  if (totalOffsets > 0 && totalOffsets < totalEntries) {\n    errors.push(new AnimationParseError(\n        `Not all style() entries contain an offset for the provided keyframe()`));\n    totalOffsets = totalEntries;\n  }\n\n  let /** @type {?} */ limit = totalEntries - 1;\n  const /** @type {?} */ margin = totalOffsets == 0 ? (1 / limit) : 0;\n  const /** @type {?} */ rawKeyframes: any[] /** TODO #9100 */ = [];\n  let /** @type {?} */ index = 0;\n  let /** @type {?} */ doSortKeyframes = false;\n  let /** @type {?} */ lastOffset = 0;\n  keyframeSequence.steps.forEach(styleMetadata => {\n    let /** @type {?} */ offset = styleMetadata.offset;\n    const /** @type {?} */ keyframeStyles: Styles = {};\n    styleMetadata.styles.forEach(entry => {\n      Object.keys(entry).forEach(prop => {\n        if (prop != 'offset') {\n          keyframeStyles[prop] = ( /** @type {?} */((entry as Styles)))[prop];\n        }\n      });\n    });\n\n    if (isPresent(offset)) {\n      doSortKeyframes = doSortKeyframes || (offset < lastOffset);\n    } else {\n      offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);\n    }\n\n    rawKeyframes.push([offset, keyframeStyles]);\n    lastOffset = offset;\n    index++;\n  });\n\n  if (doSortKeyframes) {\n    rawKeyframes.sort((a, b) => a[0] <= b[0] ? -1 : 1);\n  }\n\n  let /** @type {?} */ firstKeyframe = rawKeyframes[0];\n  if (firstKeyframe[0] != _INITIAL_KEYFRAME) {\n    rawKeyframes.splice(0, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);\n  }\n\n  const /** @type {?} */ firstKeyframeStyles = firstKeyframe[1];\n  limit = rawKeyframes.length - 1;\n  let /** @type {?} */ lastKeyframe = rawKeyframes[limit];\n  if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {\n    rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);\n    limit++;\n  }\n\n  const /** @type {?} */ lastKeyframeStyles = lastKeyframe[1];\n  for (let /** @type {?} */ i = 1; i <= limit; i++) {\n    const /** @type {?} */ entry = rawKeyframes[i];\n    const /** @type {?} */ styles = entry[1];\n\n    Object.keys(styles).forEach(prop => {\n      if (!isPresent(firstKeyframeStyles[prop])) {\n        firstKeyframeStyles[prop] = FILL_STYLE_FLAG;\n      }\n    });\n  }\n\n  for (let /** @type {?} */ i = limit - 1; i >= 0; i--) {\n    const /** @type {?} */ entry = rawKeyframes[i];\n    const /** @type {?} */ styles = entry[1];\n\n    Object.keys(styles).forEach(prop => {\n      if (!isPresent(lastKeyframeStyles[prop])) {\n        lastKeyframeStyles[prop] = styles[prop];\n      }\n    });\n  }\n\n  return rawKeyframes.map(\n      entry => new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])));\n}\n/**\n * @param {?} entry\n * @param {?} currentTime\n * @param {?} collectedStyles\n * @param {?} stateStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _parseTransitionAnimation(\n    entry: CompileAnimationMetadata, currentTime: number, collectedStyles: StylesCollection,\n    stateStyles: {[key: string]: AnimationStylesAst}, errors: AnimationParseError[]): AnimationAst {\n  let /** @type {?} */ ast: any /** TODO #9100 */;\n  let /** @type {?} */ playTime = 0;\n  const /** @type {?} */ startingTime = currentTime;\n  if (entry instanceof CompileAnimationWithStepsMetadata) {\n    let /** @type {?} */ maxDuration = 0;\n    const /** @type {?} */ steps: any[] /** TODO #9100 */ = [];\n    const /** @type {?} */ isGroup = entry instanceof CompileAnimationGroupMetadata;\n    let /** @type {?} */ previousStyles: any /** TODO #9100 */;\n    entry.steps.forEach(entry => {\n      // these will get picked up by the next step...\n      const /** @type {?} */ time = isGroup ? startingTime : currentTime;\n      if (entry instanceof CompileAnimationStyleMetadata) {\n        entry.styles.forEach(stylesEntry => {\n          // by this point we know that we only have stringmap values\n          const /** @type {?} */ map = /** @type {?} */(( stylesEntry as Styles));\n          Object.keys(map).forEach(\n              prop => { collectedStyles.insertAtTime(prop, time, map[prop]); });\n        });\n        previousStyles = entry.styles;\n        return;\n      }\n\n      const /** @type {?} */ innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);\n      if (isPresent(previousStyles)) {\n        if (entry instanceof CompileAnimationWithStepsMetadata) {\n          const /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles);\n          steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n        } else {\n          const /** @type {?} */ innerStep = /** @type {?} */(( <AnimationStepAst>innerAst));\n          innerStep.startingStyles.styles.push(...previousStyles);\n        }\n        previousStyles = null;\n      }\n\n      const /** @type {?} */ astDuration = innerAst.playTime;\n      currentTime += astDuration;\n      playTime += astDuration;\n      maxDuration = Math.max(astDuration, maxDuration);\n      steps.push(innerAst);\n    });\n    if (isPresent(previousStyles)) {\n      const /** @type {?} */ startingStyles = new AnimationStylesAst(previousStyles);\n      steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n    }\n    if (isGroup) {\n      ast = new AnimationGroupAst(steps);\n      playTime = maxDuration;\n      currentTime = startingTime + playTime;\n    } else {\n      ast = new AnimationSequenceAst(steps);\n    }\n  } else if (entry instanceof CompileAnimationAnimateMetadata) {\n    const /** @type {?} */ timings = _parseTimeExpression(entry.timings, errors);\n    const /** @type {?} */ styles = entry.styles;\n\n    let /** @type {?} */ keyframes: any /** TODO #9100 */;\n    if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {\n      keyframes =\n          _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);\n    } else {\n      const /** @type {?} */ styleData = /** @type {?} */(( <CompileAnimationStyleMetadata>styles));\n      const /** @type {?} */ offset = _TERMINAL_KEYFRAME;\n      const /** @type {?} */ styleAst = new AnimationStylesAst( /** @type {?} */((styleData.styles as Styles[])));\n      const /** @type {?} */ keyframe = new AnimationKeyframeAst(offset, styleAst);\n      keyframes = [keyframe];\n    }\n\n    ast = new AnimationStepAst(\n        new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);\n    playTime = timings.duration + timings.delay;\n    currentTime += playTime;\n\n    keyframes.forEach(\n        (keyframe: any /** TODO #9100 */) => keyframe.styles.styles.forEach(\n            (entry: any /** TODO #9100 */) => Object.keys(entry).forEach(\n                prop => { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); })));\n  } else {\n    // if the code reaches this stage then an error\n    // has already been populated within the _normalizeStyleSteps()\n    // operation...\n    ast = new AnimationStepAst(null, [], 0, 0, '');\n  }\n\n  ast.playTime = playTime;\n  ast.startTime = startingTime;\n  return ast;\n}\n/**\n * @param {?} ast\n * @param {?} collectedStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _fillAnimationAstStartingKeyframes(\n    ast: AnimationAst, collectedStyles: StylesCollection, errors: AnimationParseError[]): void {\n  // steps that only contain style will not be filled\n  if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {\n    const /** @type {?} */ keyframes = ast.keyframes;\n    if (keyframes.length == 1) {\n      const /** @type {?} */ endKeyframe = keyframes[0];\n      const /** @type {?} */ startKeyframe = _createStartKeyframeFromEndKeyframe(\n          endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);\n      ast.keyframes = [startKeyframe, endKeyframe];\n    }\n  } else if (ast instanceof AnimationWithStepsAst) {\n    ast.steps.forEach(entry => _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors));\n  }\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @return {?}\n */\nfunction _parseTimeExpression(\n    exp: string | number, errors: AnimationParseError[]): _AnimationTimings {\n  const /** @type {?} */ regex = /^([\\.\\d]+)(m?s)(?:\\s+([\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = null;\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(new AnimationParseError(`The provided timing value \"${exp}\" is invalid.`));\n      return new _AnimationTimings(0, 0, null);\n    }\n\n    let /** @type {?} */ durationMatch = parseFloat(matches[1]);\n    const /** @type {?} */ durationUnit = matches[2];\n    if (durationUnit == 's') {\n      durationMatch *= _ONE_SECOND;\n    }\n    duration = Math.floor(durationMatch);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    const /** @type {?} */ delayUnit = matches[4];\n    if (isPresent(delayMatch)) {\n      let /** @type {?} */ delayVal: number = parseFloat(delayMatch);\n      if (isPresent(delayUnit) && delayUnit == 's') {\n        delayVal *= _ONE_SECOND;\n      }\n      delay = Math.floor(delayVal);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (!isBlank(easingVal)) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  return new _AnimationTimings(duration, delay, easing);\n}\n/**\n * @param {?} endKeyframe\n * @param {?} startTime\n * @param {?} duration\n * @param {?} collectedStyles\n * @param {?} errors\n * @return {?}\n */\nfunction _createStartKeyframeFromEndKeyframe(\n    endKeyframe: AnimationKeyframeAst, startTime: number, duration: number,\n    collectedStyles: StylesCollection, errors: AnimationParseError[]): AnimationKeyframeAst {\n  const /** @type {?} */ values: Styles = {};\n  const /** @type {?} */ endTime = startTime + duration;\n  endKeyframe.styles.styles.forEach((styleData: Styles) => {\n    Object.keys(styleData).forEach(prop => {\n      const /** @type {?} */ val = styleData[prop];\n      if (prop == 'offset') return;\n\n      const /** @type {?} */ resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);\n      let /** @type {?} */ resultEntry: any /** TODO #9100 */, /** @type {?} */ nextEntry: any /** TODO #9100 */, /** @type {?} */\n          value: any /** TODO #9100 */;\n      if (isPresent(resultIndex)) {\n        resultEntry = collectedStyles.getByIndex(prop, resultIndex);\n        value = resultEntry.value;\n        nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);\n      } else {\n        // this is a flag that the runtime code uses to pass\n        // in a value either from the state declaration styles\n        // or using the AUTO_STYLE value (e.g. getComputedStyle)\n        value = FILL_STYLE_FLAG;\n      }\n\n      if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {\n        errors.push(new AnimationParseError(\n            `The animated CSS property \"${prop}\" unexpectedly changes between steps \"${resultEntry.time}ms\" and \"${endTime}ms\" at \"${nextEntry.time}ms\"`));\n      }\n\n      values[prop] = value;\n    });\n  });\n\n  return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));\n}\n"]}