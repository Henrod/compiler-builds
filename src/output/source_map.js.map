{"version":3,"sources":["../../../../../modules/@angular/compiler/src/output/source_map.ts"],"names":[],"mappings":"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","file":"source_map.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst /** @type {?} */ VERSION = 3;\n\nconst /** @type {?} */ JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n  sourceRoot: string,\n  sources: string[],\n  sourcesContent: string[],\n  mappings: string,\n};\nexport class SourceMapGenerator {\nprivate sourcesContent: Map<string, string> = new Map();\nprivate lines: Segment[][] = [];\nprivate lastCol0: number = 0;\nprivate hasMappings = false;\n/**\n * @param {?=} file\n */\nconstructor(private file: string|null = null) {}\n/**\n * @param {?} url\n * @param {?=} content\n * @return {?}\n */\naddSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n/**\n * @return {?}\n */\naddLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n/**\n * @param {?} col0\n * @param {?=} sourceUrl\n * @param {?=} sourceLine0\n * @param {?=} sourceCol0\n * @return {?}\n */\naddMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n/**\n * @return {?}\n */\nprivate get currentLine(): Segment[]|null { return this.lines.slice(-1)[0]; }\n/**\n * @return {?}\n */\ntoJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const /** @type {?} */ sourcesIndex = new Map<string, number>();\n    const /** @type {?} */ sources: string[] = [];\n    const /** @type {?} */ sourcesContent: string[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let /** @type {?} */ mappings: string = '';\n    let /** @type {?} */ lastCol0: number = 0;\n    let /** @type {?} */ lastSourceIndex: number = 0;\n    let /** @type {?} */ lastSourceLine0: number = 0;\n    let /** @type {?} */ lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the “sources” list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n/**\n * @return {?}\n */\ntoJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nfunction SourceMapGenerator_tsickle_Closure_declarations() {\n/** @type {?} */\nSourceMapGenerator.prototype.sourcesContent;\n/** @type {?} */\nSourceMapGenerator.prototype.lines;\n/** @type {?} */\nSourceMapGenerator.prototype.lastCol0;\n/** @type {?} */\nSourceMapGenerator.prototype.hasMappings;\n/** @type {?} */\nSourceMapGenerator.prototype.file;\n}\n\n/**\n * @param {?} value\n * @return {?}\n */\nexport function toBase64String(value: string): string {\n  let /** @type {?} */ b64 = '';\n\n  for (let /** @type {?} */ i = 0; i < value.length;) {\n    const /** @type {?} */ i1 = value.charCodeAt(i++);\n    const /** @type {?} */ i2 = value.charCodeAt(i++);\n    const /** @type {?} */ i3 = value.charCodeAt(i++);\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n    b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n    b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let /** @type {?} */ out = '';\n  do {\n    let /** @type {?} */ digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst /** @type {?} */ B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n"]}