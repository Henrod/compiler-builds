{"version":3,"sources":["../../../../../modules/@angular/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","file":"expression_converter.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport * as cdAst from '../expression_parser/ast';\nimport {isBlank} from '../facade/lang';\nimport {Identifiers, createIdentifier} from '../identifiers';\nimport {ClassBuilder} from '../output/class_builder';\nimport * as o from '../output/output_ast';\n\nimport {createPureProxy} from './identifier_util';\n\nconst /** @type {?} */ VAL_UNWRAPPER_VAR = o.variable(`valUnwrapper`);\n\nexport interface NameResolver {\n  callPipe(name: string, input: o.Expression, args: o.Expression[]): o.Expression;\n  getLocal(name: string): o.Expression;\n}\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nfunction EventHandlerVars_tsickle_Closure_declarations() {\n/** @type {?} */\nEventHandlerVars.event;\n}\n\nexport class ConvertPropertyBindingResult {\n/**\n * @param {?} stmts\n * @param {?} currValExpr\n * @param {?} forceUpdate\n */\nconstructor(\npublic stmts: o.Statement[],\npublic currValExpr: o.Expression,\npublic forceUpdate: o.Expression) {}\n}\n\nfunction ConvertPropertyBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertPropertyBindingResult.prototype.stmts;\n/** @type {?} */\nConvertPropertyBindingResult.prototype.currValExpr;\n/** @type {?} */\nConvertPropertyBindingResult.prototype.forceUpdate;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in a property binding.\n * @param {?} builder\n * @param {?} nameResolver\n * @param {?} implicitReceiver\n * @param {?} expression\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertPropertyBinding(\n    builder: ClassBuilder, nameResolver: NameResolver, implicitReceiver: o.Expression,\n    expression: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  const /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n  const /** @type {?} */ stmts: o.Statement[] = [];\n  if (!nameResolver) {\n    nameResolver = new DefaultNameResolver();\n  }\n  const /** @type {?} */ visitor = new _AstToIrVisitor(\n      builder, nameResolver, implicitReceiver, VAL_UNWRAPPER_VAR, bindingId, false);\n  const /** @type {?} */ outputExpr: o.Expression = expression.visit(visitor, _Mode.Expression);\n\n  if (!outputExpr) {\n    // e.g. an empty expression was given\n    return null;\n  }\n\n  if (visitor.temporaryCount) {\n    for (let /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  }\n\n  if (visitor.needsValueUnwrapper) {\n    const /** @type {?} */ initValueUnwrapperStmt = VAL_UNWRAPPER_VAR.callMethod('reset', []).toStmt();\n    stmts.push(initValueUnwrapperStmt);\n  }\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [o.StmtModifier.Final]));\n  if (visitor.needsValueUnwrapper) {\n    return new ConvertPropertyBindingResult(\n        stmts, currValExpr, VAL_UNWRAPPER_VAR.prop('hasWrappedValue'));\n  } else {\n    return new ConvertPropertyBindingResult(stmts, currValExpr, null);\n  }\n}\nexport class ConvertActionBindingResult {\n/**\n * @param {?} stmts\n * @param {?} allowDefault\n */\nconstructor(public stmts: o.Statement[],\npublic allowDefault: o.ReadVarExpr) {}\n}\n\nfunction ConvertActionBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertActionBindingResult.prototype.stmts;\n/** @type {?} */\nConvertActionBindingResult.prototype.allowDefault;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} builder\n * @param {?} nameResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertActionBinding(\n    builder: ClassBuilder, nameResolver: NameResolver, implicitReceiver: o.Expression,\n    action: cdAst.AST, bindingId: string): ConvertActionBindingResult {\n  if (!nameResolver) {\n    nameResolver = new DefaultNameResolver();\n  }\n  const /** @type {?} */ visitor =\n      new _AstToIrVisitor(builder, nameResolver, implicitReceiver, null, bindingId, true);\n  const /** @type {?} */ actionStmts: o.Statement[] = [];\n  flattenStatements(action.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const /** @type {?} */ lastIndex = actionStmts.length - 1;\n  let /** @type {?} */ preventDefaultVar: o.ReadVarExpr = null;\n  if (lastIndex >= 0) {\n    const /** @type {?} */ lastStatement = actionStmts[lastIndex];\n    const /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * Creates variables that are shared by multiple calls to `convertActionBinding` /\n * `convertPropertyBinding`\n * @param {?} stmts\n * @return {?}\n */\nexport function createSharedBindingVariablesIfNeeded(stmts: o.Statement[]): o.Statement[] {\n  const /** @type {?} */ unwrapperStmts: o.Statement[] = [];\n  const /** @type {?} */ readVars = o.findReadVarNames(stmts);\n  if (readVars.has(VAL_UNWRAPPER_VAR.name)) {\n    unwrapperStmts.push(\n        VAL_UNWRAPPER_VAR\n            .set(o.importExpr(createIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))\n            .toDeclStmt(null, [o.StmtModifier.Final]));\n  }\n  return unwrapperStmts;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\ntype _Mode = number;\nlet _Mode: any = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\nclass _AstToIrVisitor implements cdAst.AstVisitor {\nprivate _nodeMap = new Map<cdAst.AST, cdAst.AST>();\nprivate _resultMap = new Map<cdAst.AST, o.Expression>();\nprivate _currentTemporary: number = 0;\npublic needsValueUnwrapper: boolean = false;\npublic temporaryCount: number = 0;\n/**\n * @param {?} _builder\n * @param {?} _nameResolver\n * @param {?} _implicitReceiver\n * @param {?} _valueUnwrapper\n * @param {?} bindingId\n * @param {?} isAction\n */\nconstructor(\nprivate _builder: ClassBuilder,\nprivate _nameResolver: NameResolver,\nprivate _implicitReceiver: o.Expression,\nprivate _valueUnwrapper: o.ReadVarExpr,\nprivate bindingId: string,\nprivate isAction: boolean) {}\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let /** @type {?} */ op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const /** @type {?} */ value: o.Expression = this.visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    const /** @type {?} */ input = this.visit(ast.exp, _Mode.Expression);\n    const /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n    const /** @type {?} */ value = this._nameResolver.callPipe(ast.name, input, args);\n    if (!value) {\n      throw new Error(`Illegal state: Pipe ${ast.name} is not allowed here!`);\n    }\n    this.needsValueUnwrapper = true;\n    return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode,\n        this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const /** @type {?} */ args = [o.literal(ast.expressions.length)];\n    for (let /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this.visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    return ast.expressions.length <= 9 ?\n        o.importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n        o.importExpr(createIdentifier(Identifiers.interpolate)).callFn([\n          args[0], o.literalArr(args.slice(1))\n        ]);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const /** @type {?} */ obj: o.Expression = this.visit(ast.obj, _Mode.Expression);\n    const /** @type {?} */ key: o.Expression = this.visit(ast.key, _Mode.Expression);\n    const /** @type {?} */ value: o.Expression = this.visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    const /** @type {?} */ parts = this.visitAll(ast.expressions, mode);\n    const /** @type {?} */ literalArr =\n        this.isAction ? o.literalArr(parts) : createCachedLiteralArray(this._builder, parts);\n    return convertToStatementIfNeeded(mode, literalArr);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    const /** @type {?} */ parts: any[] = [];\n    for (let /** @type {?} */ i = 0; i < ast.keys.length; i++) {\n      parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);\n    }\n    const /** @type {?} */ literalMap =\n        this.isAction ? o.literalMap(parts) : createCachedLiteralMap(this._builder, parts);\n    return convertToStatementIfNeeded(mode, literalMap);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.literal(ast.value));\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nprivate _getLocal(name: string): o.Expression {\n    if (this.isAction && name == EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return this._nameResolver.getLocal(name);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const /** @type {?} */ varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (isBlank(result)) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this.visit(ast.expression, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (isBlank(result)) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const /** @type {?} */ receiver: o.Expression = this.visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      const /** @type {?} */ varExpr = this._getLocal(ast.name);\n      if (varExpr) {\n        throw new Error('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} asts\n * @param {?} mode\n * @return {?}\n */\nvisitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this.visit(ast, mode)); }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error('Quotes are not supported for evaluation!');\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nprivate visit(ast: cdAst.AST, mode: _Mode): any {\n    const /** @type {?} */ result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} leftMostSafe\n * @param {?} mode\n * @return {?}\n */\nprivate convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n    let /** @type {?} */ temporary: o.ReadVarExpr;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const /** @type {?} */ condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const /** @type {?} */ access = this.visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allcoated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\nprivate leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\nprivate needsTemporary(ast: cdAst.AST): boolean {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const /** @type {?} */ visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n/**\n * @return {?}\n */\nprivate allocateTemporary(): o.ReadVarExpr {\n    const /** @type {?} */ tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n/**\n * @param {?} temporary\n * @return {?}\n */\nprivate releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction _AstToIrVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\n_AstToIrVisitor.prototype._nodeMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._resultMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._currentTemporary;\n/** @type {?} */\n_AstToIrVisitor.prototype.needsValueUnwrapper;\n/** @type {?} */\n_AstToIrVisitor.prototype.temporaryCount;\n/** @type {?} */\n_AstToIrVisitor.prototype._builder;\n/** @type {?} */\n_AstToIrVisitor.prototype._nameResolver;\n/** @type {?} */\n_AstToIrVisitor.prototype._implicitReceiver;\n/** @type {?} */\n_AstToIrVisitor.prototype._valueUnwrapper;\n/** @type {?} */\n_AstToIrVisitor.prototype.bindingId;\n/** @type {?} */\n_AstToIrVisitor.prototype.isAction;\n}\n\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    ( /** @type {?} */((<any[]>arg))).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n/**\n * @param {?} builder\n * @param {?} values\n * @return {?}\n */\nfunction createCachedLiteralArray(builder: ClassBuilder, values: o.Expression[]): o.Expression {\n  if (values.length === 0) {\n    return o.importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));\n  }\n  const /** @type {?} */ proxyExpr = o.THIS_EXPR.prop(`_arr_${builder.fields.length}`);\n  const /** @type {?} */ proxyParams: o.FnParam[] = [];\n  const /** @type {?} */ proxyReturnEntries: o.Expression[] = [];\n  for (let /** @type {?} */ i = 0; i < values.length; i++) {\n    const /** @type {?} */ paramName = `p${i}`;\n    proxyParams.push(new o.FnParam(paramName));\n    proxyReturnEntries.push(o.variable(paramName));\n  }\n  createPureProxy(\n      o.fn(\n          proxyParams, [new o.ReturnStatement(o.literalArr(proxyReturnEntries))],\n          new o.ArrayType(o.DYNAMIC_TYPE)),\n      values.length, proxyExpr, builder);\n  return proxyExpr.callFn(values);\n}\n/**\n * @param {?} builder\n * @param {?} entries\n * @return {?}\n */\nfunction createCachedLiteralMap(\n    builder: ClassBuilder, entries: [string, o.Expression][]): o.Expression {\n  if (entries.length === 0) {\n    return o.importExpr(createIdentifier(Identifiers.EMPTY_MAP));\n  }\n  const /** @type {?} */ proxyExpr = o.THIS_EXPR.prop(`_map_${builder.fields.length}`);\n  const /** @type {?} */ proxyParams: o.FnParam[] = [];\n  const /** @type {?} */ proxyReturnEntries: [string, o.Expression][] = [];\n  const /** @type {?} */ values: o.Expression[] = [];\n  for (let /** @type {?} */ i = 0; i < entries.length; i++) {\n    const /** @type {?} */ paramName = `p${i}`;\n    proxyParams.push(new o.FnParam(paramName));\n    proxyReturnEntries.push([entries[i][0], o.variable(paramName)]);\n    values.push( /** @type {?} */((<o.Expression>entries[i][1])));\n  }\n  createPureProxy(\n      o.fn(\n          proxyParams, [new o.ReturnStatement(o.literalMap(proxyReturnEntries))],\n          new o.MapType(o.DYNAMIC_TYPE)),\n      entries.length, proxyExpr, builder);\n  return proxyExpr.callFn(values);\n}\nclass DefaultNameResolver implements NameResolver {\n/**\n * @param {?} name\n * @param {?} input\n * @param {?} args\n * @return {?}\n */\ncallPipe(name: string, input: o.Expression, args: o.Expression[]): o.Expression { return null; }\n/**\n * @param {?} name\n * @return {?}\n */\ngetLocal(name: string): o.Expression { return null; }\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n"]}