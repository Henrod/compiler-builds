{"version":3,"sources":["../../../../../modules/@angular/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","file":"expression_converter.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport * as cdAst from '../expression_parser/ast';\nimport {isBlank} from '../facade/lang';\nimport {Identifiers, createIdentifier} from '../identifiers';\nimport {ClassBuilder} from '../output/class_builder';\nimport * as o from '../output/output_ast';\n\nimport {createPureProxy} from './identifier_util';\n\nconst /** @type {?} */ VAL_UNWRAPPER_VAR = o.variable(`valUnwrapper`);\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nfunction EventHandlerVars_tsickle_Closure_declarations() {\n/** @type {?} */\nEventHandlerVars.event;\n}\n\n\nexport interface LocalResolver { getLocal(name: string): o.Expression; }\nexport class ConvertActionBindingResult {\n/**\n * @param {?} stmts\n * @param {?} allowDefault\n */\nconstructor(public stmts: o.Statement[],\npublic allowDefault: o.ReadVarExpr) {}\n}\n\nfunction ConvertActionBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertActionBindingResult.prototype.stmts;\n/** @type {?} */\nConvertActionBindingResult.prototype.allowDefault;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: string[]) => {\n          // Note: no caching for literal maps in actions.\n          return (args: o.Expression[]) =>\n                     o.literalMap( /** @type {?} */((<[string, o.Expression][]>keys.map((key, i) => [key, args[i]]))));\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n  const /** @type {?} */ actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const /** @type {?} */ lastIndex = actionStmts.length - 1;\n  let /** @type {?} */ preventDefaultVar: o.ReadVarExpr = null;\n  if (lastIndex >= 0) {\n    const /** @type {?} */ lastStatement = actionStmts[lastIndex];\n    const /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: string[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\nexport class ConvertPropertyBindingResult {\n/**\n * @param {?} stmts\n * @param {?} currValExpr\n */\nconstructor(public stmts: o.Statement[],\npublic currValExpr: o.Expression) {}\n}\n\nfunction ConvertPropertyBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertPropertyBindingResult.prototype.stmts;\n/** @type {?} */\nConvertPropertyBindingResult.prototype.currValExpr;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n  const /** @type {?} */ stmts: o.Statement[] = [];\n  const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n  const /** @type {?} */ outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n\n  if (visitor.temporaryCount) {\n    for (let /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\nexport class LegacyConvertPropertyBindingResult implements ConvertPropertyBindingResult {\n/**\n * @param {?} stmts\n * @param {?} currValExpr\n * @param {?} forceUpdate\n */\nconstructor(\npublic stmts: o.Statement[],\npublic currValExpr: o.Expression,\npublic forceUpdate: o.Expression) {}\n}\n\nfunction LegacyConvertPropertyBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nLegacyConvertPropertyBindingResult.prototype.stmts;\n/** @type {?} */\nLegacyConvertPropertyBindingResult.prototype.currValExpr;\n/** @type {?} */\nLegacyConvertPropertyBindingResult.prototype.forceUpdate;\n}\n\n\nexport interface LegacyNameResolver {\n  callPipe(name: string, input: o.Expression, args: o.Expression[]): o.Expression;\n  getLocal(name: string): o.Expression;\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in a property binding.\n * @param {?} builder\n * @param {?} nameResolver\n * @param {?} implicitReceiver\n * @param {?} expression\n * @param {?} bindingId\n * @return {?}\n */\nexport function legacyConvertPropertyBinding(\n    builder: ClassBuilder, nameResolver: LegacyNameResolver, implicitReceiver: o.Expression,\n    expression: cdAst.AST, bindingId: string): LegacyConvertPropertyBindingResult {\n  if (!nameResolver) {\n    nameResolver = new LegacyDefaultNameResolver();\n  }\n  let /** @type {?} */ needsValueUnwrapper = false;\n  const /** @type {?} */ expressionWithoutBuiltins = convertBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          return (args: o.Expression[]) => legacyCreateCachedLiteralArray(builder, args);\n        },\n        createLiteralMapConverter: (keys: string[]) => {\n          return (args: o.Expression[]) => legacyCreateCachedLiteralMap(\n                     builder, /** @type {?} */(( <[string, o.Expression][]>keys.map((key, i) => [key, args[i]]))));\n        },\n        createPipeConverter: (name: string) => {\n          needsValueUnwrapper = true;\n          return (args: o.Expression[]) => VAL_UNWRAPPER_VAR.callMethod(\n                     'unwrap', [nameResolver.callPipe(name, args[0], args.slice(1))]);\n        }\n      },\n      expression);\n\n  const {stmts, currValExpr} =\n      convertPropertyBinding(nameResolver, implicitReceiver, expressionWithoutBuiltins, bindingId);\n  let /** @type {?} */ forceUpdate: o.Expression = null;\n  if (needsValueUnwrapper) {\n    const /** @type {?} */ initValueUnwrapperStmt = VAL_UNWRAPPER_VAR.callMethod('reset', []).toStmt();\n    stmts.unshift(initValueUnwrapperStmt);\n    forceUpdate = VAL_UNWRAPPER_VAR.prop('hasWrappedValue');\n  }\n  return new LegacyConvertPropertyBindingResult(stmts, currValExpr, forceUpdate);\n}\n/**\n * Creates variables that are shared by multiple calls to `convertActionBinding` /\n * `convertPropertyBinding`\n * @param {?} stmts\n * @return {?}\n */\nexport function legacyCreateSharedBindingVariablesIfNeeded(stmts: o.Statement[]): o.Statement[] {\n  const /** @type {?} */ unwrapperStmts: o.Statement[] = [];\n  const /** @type {?} */ readVars = o.findReadVarNames(stmts);\n  if (readVars.has(VAL_UNWRAPPER_VAR.name)) {\n    unwrapperStmts.push(\n        VAL_UNWRAPPER_VAR\n            .set(o.importExpr(createIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))\n            .toDeclStmt(null, [o.StmtModifier.Final]));\n  }\n  return unwrapperStmts;\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\ntype _Mode = number;\nlet _Mode: any = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n/**\n * @param {?} _converterFactory\n */\nconstructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const /** @type {?} */ args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const /** @type {?} */ args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const /** @type {?} */ args = ast.values.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nfunction _BuiltinAstConverter_tsickle_Closure_declarations() {\n/** @type {?} */\n_BuiltinAstConverter.prototype._converterFactory;\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\nprivate _nodeMap = new Map<cdAst.AST, cdAst.AST>();\nprivate _resultMap = new Map<cdAst.AST, o.Expression>();\nprivate _currentTemporary: number = 0;\npublic temporaryCount: number = 0;\n/**\n * @param {?} _localResolver\n * @param {?} _implicitReceiver\n * @param {?} bindingId\n */\nconstructor(\nprivate _localResolver: LocalResolver,\nprivate _implicitReceiver: o.Expression,\nprivate bindingId: string) {}\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let /** @type {?} */ op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const /** @type {?} */ value: o.Expression = this.visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let /** @type {?} */ fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this.visit(ast.target, _Mode.Expression).callFn(convertedArgs);\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const /** @type {?} */ args = [o.literal(ast.expressions.length)];\n    for (let /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this.visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    return ast.expressions.length <= 9 ?\n        o.importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n        o.importExpr(createIdentifier(Identifiers.interpolate)).callFn([\n          args[0], o.literalArr(args.slice(1))\n        ]);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const /** @type {?} */ obj: o.Expression = this.visit(ast.obj, _Mode.Expression);\n    const /** @type {?} */ key: o.Expression = this.visit(ast.key, _Mode.Expression);\n    const /** @type {?} */ value: o.Expression = this.visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.literal(ast.value));\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nprivate _getLocal(name: string): o.Expression { return this._localResolver.getLocal(name); }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const /** @type {?} */ varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (isBlank(result)) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this.visit(ast.expression, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (isBlank(result)) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const /** @type {?} */ receiver: o.Expression = this.visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      const /** @type {?} */ varExpr = this._getLocal(ast.name);\n      if (varExpr) {\n        throw new Error('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} asts\n * @param {?} mode\n * @return {?}\n */\nvisitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this.visit(ast, mode)); }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error('Quotes are not supported for evaluation!');\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nprivate visit(ast: cdAst.AST, mode: _Mode): any {\n    const /** @type {?} */ result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} leftMostSafe\n * @param {?} mode\n * @return {?}\n */\nprivate convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n    let /** @type {?} */ temporary: o.ReadVarExpr;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const /** @type {?} */ condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const /** @type {?} */ access = this.visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allcoated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\nprivate leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\nprivate needsTemporary(ast: cdAst.AST): boolean {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const /** @type {?} */ visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n/**\n * @return {?}\n */\nprivate allocateTemporary(): o.ReadVarExpr {\n    const /** @type {?} */ tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n/**\n * @param {?} temporary\n * @return {?}\n */\nprivate releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction _AstToIrVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\n_AstToIrVisitor.prototype._nodeMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._resultMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._currentTemporary;\n/** @type {?} */\n_AstToIrVisitor.prototype.temporaryCount;\n/** @type {?} */\n_AstToIrVisitor.prototype._localResolver;\n/** @type {?} */\n_AstToIrVisitor.prototype._implicitReceiver;\n/** @type {?} */\n_AstToIrVisitor.prototype.bindingId;\n}\n\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    ( /** @type {?} */((<any[]>arg))).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n/**\n * @param {?} builder\n * @param {?} values\n * @return {?}\n */\nfunction legacyCreateCachedLiteralArray(\n    builder: ClassBuilder, values: o.Expression[]): o.Expression {\n  if (values.length === 0) {\n    return o.importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));\n  }\n  const /** @type {?} */ proxyExpr = o.THIS_EXPR.prop(`_arr_${builder.fields.length}`);\n  const /** @type {?} */ proxyParams: o.FnParam[] = [];\n  const /** @type {?} */ proxyReturnEntries: o.Expression[] = [];\n  for (let /** @type {?} */ i = 0; i < values.length; i++) {\n    const /** @type {?} */ paramName = `p${i}`;\n    proxyParams.push(new o.FnParam(paramName));\n    proxyReturnEntries.push(o.variable(paramName));\n  }\n  createPureProxy(\n      o.fn(\n          proxyParams, [new o.ReturnStatement(o.literalArr(proxyReturnEntries))],\n          new o.ArrayType(o.DYNAMIC_TYPE)),\n      values.length, proxyExpr, builder);\n  return proxyExpr.callFn(values);\n}\n/**\n * @param {?} builder\n * @param {?} entries\n * @return {?}\n */\nfunction legacyCreateCachedLiteralMap(\n    builder: ClassBuilder, entries: [string, o.Expression][]): o.Expression {\n  if (entries.length === 0) {\n    return o.importExpr(createIdentifier(Identifiers.EMPTY_MAP));\n  }\n  const /** @type {?} */ proxyExpr = o.THIS_EXPR.prop(`_map_${builder.fields.length}`);\n  const /** @type {?} */ proxyParams: o.FnParam[] = [];\n  const /** @type {?} */ proxyReturnEntries: [string, o.Expression][] = [];\n  const /** @type {?} */ values: o.Expression[] = [];\n  for (let /** @type {?} */ i = 0; i < entries.length; i++) {\n    const /** @type {?} */ paramName = `p${i}`;\n    proxyParams.push(new o.FnParam(paramName));\n    proxyReturnEntries.push([entries[i][0], o.variable(paramName)]);\n    values.push( /** @type {?} */((<o.Expression>entries[i][1])));\n  }\n  createPureProxy(\n      o.fn(\n          proxyParams, [new o.ReturnStatement(o.literalMap(proxyReturnEntries))],\n          new o.MapType(o.DYNAMIC_TYPE)),\n      entries.length, proxyExpr, builder);\n  return proxyExpr.callFn(values);\n}\nclass DefaultLocalResolver implements LocalResolver {\n/**\n * @param {?} name\n * @return {?}\n */\ngetLocal(name: string): o.Expression {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\nclass LegacyDefaultNameResolver implements LegacyNameResolver {\n/**\n * @param {?} name\n * @param {?} input\n * @param {?} args\n * @return {?}\n */\ncallPipe(name: string, input: o.Expression, args: o.Expression[]): o.Expression { return null; }\n/**\n * @param {?} name\n * @return {?}\n */\ngetLocal(name: string): o.Expression {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\nclass BuiltinFunctionCall extends cdAst.FunctionCall {\n/**\n * @param {?} span\n * @param {?} args\n * @param {?} converter\n */\nconstructor(span: cdAst.ParseSpan,\npublic args: cdAst.AST[],\npublic converter: BuiltinConverter) {\n    super(span, null, args);\n  }\n}\n\nfunction BuiltinFunctionCall_tsickle_Closure_declarations() {\n/** @type {?} */\nBuiltinFunctionCall.prototype.args;\n/** @type {?} */\nBuiltinFunctionCall.prototype.converter;\n}\n"]}