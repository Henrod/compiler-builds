{"version":3,"file":"message_extractor.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/i18n/message_extractor.ts"],"names":[],"mappings":"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","sourcesContent":["import {Parser} from '../expression_parser/parser';\nimport {StringMapWrapper} from '../facade/collection';\nimport {isPresent} from '../facade/lang';\nimport {HtmlAst, HtmlElementAst} from '../html_ast';\nimport {HtmlParser} from '../html_parser';\nimport {ParseError} from '../parse_util';\n\nimport {expandNodes} from './expander';\nimport {Message, id} from './message';\nimport {I18N_ATTR_PREFIX, I18nError, Part, messageFromAttribute, messageFromI18nAttribute, partition} from './shared';\n\n\n/**\n * All messages extracted from a template.\n */\nexport class ExtractionResult {\n  constructor(public messages: Message[], public errors: ParseError[]) {}\n}\n\n/**\n * Removes duplicate messages.\n */\nexport function removeDuplicates(messages: Message[]): Message[] {\n  let uniq: {[key: string]: Message} = {};\n  messages.forEach(m => {\n    if (!StringMapWrapper.contains(uniq, id(m))) {\n      uniq[id(m)] = m;\n    }\n  });\n  return StringMapWrapper.values(uniq);\n}\n\n/**\n * Extracts all messages from a template.\n *\n * Algorithm:\n *\n * To understand the algorithm, you need to know how partitioning works.\n * Partitioning is required as we can use two i18n comments to group node siblings together.\n * That is why we cannot just use nodes.\n *\n * Partitioning transforms an array of HtmlAst into an array of Part.\n * A part can optionally contain a root element or a root text node. And it can also contain\n * children.\n * A part can contain i18n property, in which case it needs to be extracted.\n *\n * Example:\n *\n * The following array of nodes will be split into four parts:\n *\n * ```\n * <a>A</a>\n * <b i18n>B</b>\n * <!-- i18n -->\n * <c>C</c>\n * D\n * <!-- /i18n -->\n * E\n * ```\n *\n * Part 1 containing the a tag. It should not be translated.\n * Part 2 containing the b tag. It should be translated.\n * Part 3 containing the c tag and the D text node. It should be translated.\n * Part 4 containing the E text node. It should not be translated..\n *\n * It is also important to understand how we stringify nodes to create a message.\n *\n * We walk the tree and replace every element node with a placeholder. We also replace\n * all expressions in interpolation with placeholders. We also insert a placeholder element\n * to wrap a text node containing interpolation.\n *\n * Example:\n *\n * The following tree:\n *\n * ```\n * <a>A{{I}}</a><b>B</b>\n * ```\n *\n * will be stringified into:\n * ```\n * <ph name=\"e0\"><ph name=\"t1\">A<ph name=\"0\"/></ph></ph><ph name=\"e2\">B</ph>\n * ```\n *\n * This is what the algorithm does:\n *\n * 1. Use the provided html parser to get the html AST of the template.\n * 2. Partition the root nodes, and process each part separately.\n * 3. If a part does not have the i18n attribute, recurse to process children and attributes.\n * 4. If a part has the i18n attribute, stringify the nodes to create a Message.\n */\nexport class MessageExtractor {\n  messages: Message[];\n  errors: ParseError[];\n\n  constructor(\n      private _htmlParser: HtmlParser, private _parser: Parser, private _implicitTags: string[],\n      private _implicitAttrs: {[k: string]: string[]}) {}\n\n  extract(template: string, sourceUrl: string): ExtractionResult {\n    this.messages = [];\n    this.errors = [];\n\n    let res = this._htmlParser.parse(template, sourceUrl, true);\n    if (res.errors.length > 0) {\n      return new ExtractionResult([], res.errors);\n    } else {\n      let expanded = expandNodes(res.rootNodes);\n      this._recurse(expanded.nodes);\n      return new ExtractionResult(this.messages, this.errors.concat(expanded.errors));\n    }\n  }\n\n  private _extractMessagesFromPart(p: Part): void {\n    if (p.hasI18n) {\n      this.messages.push(p.createMessage(this._parser));\n      this._recurseToExtractMessagesFromAttributes(p.children);\n    } else {\n      this._recurse(p.children);\n    }\n\n    if (isPresent(p.rootElement)) {\n      this._extractMessagesFromAttributes(p.rootElement);\n    }\n  }\n\n  private _recurse(nodes: HtmlAst[]): void {\n    if (isPresent(nodes)) {\n      let ps = partition(nodes, this.errors, this._implicitTags);\n      ps.forEach(p => this._extractMessagesFromPart(p));\n    }\n  }\n\n  private _recurseToExtractMessagesFromAttributes(nodes: HtmlAst[]): void {\n    nodes.forEach(n => {\n      if (n instanceof HtmlElementAst) {\n        this._extractMessagesFromAttributes(n);\n        this._recurseToExtractMessagesFromAttributes(n.children);\n      }\n    });\n  }\n\n  private _extractMessagesFromAttributes(p: HtmlElementAst): void {\n    let transAttrs: string[] =\n        isPresent(this._implicitAttrs[p.name]) ? this._implicitAttrs[p.name] : [];\n    let explicitAttrs: string[] = [];\n\n    p.attrs.forEach(attr => {\n      if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n        try {\n          explicitAttrs.push(attr.name.substring(I18N_ATTR_PREFIX.length));\n          this.messages.push(messageFromI18nAttribute(this._parser, p, attr));\n        } catch (e) {\n          if (e instanceof I18nError) {\n            this.errors.push(e);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n\n    p.attrs.filter(attr => !attr.name.startsWith(I18N_ATTR_PREFIX))\n        .filter(attr => explicitAttrs.indexOf(attr.name) == -1)\n        .filter(attr => transAttrs.indexOf(attr.name) > -1)\n        .forEach(attr => this.messages.push(messageFromAttribute(this._parser, attr)));\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}