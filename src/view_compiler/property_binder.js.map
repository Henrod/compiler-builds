{"version":3,"sources":["../../../../../modules/@angular/compiler/src/view_compiler/property_binder.ts"],"names":[],"mappings":"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","file":"property_binder.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '@angular/core/index';\n\nimport {createCheckBindingField} from '../compiler_util/binding_util';\nimport {convertPropertyBinding} from '../compiler_util/expression_converter';\nimport {createEnumExpression} from '../compiler_util/identifier_util';\nimport {createCheckAnimationBindingStmts, createCheckRenderBindingStmt} from '../compiler_util/render_util';\nimport {DirectiveWrapperExpressions} from '../directive_wrapper_compiler';\nimport {Identifiers, createIdentifier} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {isDefaultChangeDetectionStrategy} from '../private_import_core';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, PropertyBindingType} from '../template_parser/template_ast';\n\nimport {CompileElement, CompileNode} from './compile_element';\nimport {CompileView} from './compile_view';\nimport {getHandleEventMethodName} from './util';\n/**\n * @param {?} boundText\n * @param {?} compileNode\n * @param {?} view\n * @return {?}\n */\nexport function bindRenderText(\n    boundText: BoundTextAst, compileNode: CompileNode, view: CompileView): void {\n  const /** @type {?} */ valueField = createCheckBindingField(view);\n  const /** @type {?} */ evalResult = convertPropertyBinding(\n      view, view, view.componentContext, boundText.value, valueField.bindingId);\n  if (!evalResult) {\n    return null;\n  }\n\n  view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);\n  view.detectChangesRenderPropertiesMethod.addStmts(evalResult.stmts);\n  view.detectChangesRenderPropertiesMethod.addStmt(\n      o.importExpr(createIdentifier(Identifiers.checkRenderText))\n          .callFn([\n            o.THIS_EXPR, compileNode.renderNode, valueField.expression,\n            valueField.expression.set(evalResult.currValExpr),\n            evalResult.forceUpdate || o.literal(false)\n          ])\n          .toStmt());\n}\n/**\n * @param {?} boundProps\n * @param {?} boundOutputs\n * @param {?} hasEvents\n * @param {?} compileElement\n * @return {?}\n */\nexport function bindRenderInputs(\n    boundProps: BoundElementPropertyAst[], boundOutputs: BoundEventAst[], hasEvents: boolean,\n    compileElement: CompileElement) {\n  const /** @type {?} */ view = compileElement.view;\n  const /** @type {?} */ renderNode = compileElement.renderNode;\n\n  boundProps.forEach((boundProp) => {\n    const /** @type {?} */ bindingField = createCheckBindingField(view);\n    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);\n    const /** @type {?} */ evalResult = convertPropertyBinding(\n        view, view, compileElement.view.componentContext, boundProp.value, bindingField.bindingId);\n    if (!evalResult) {\n      return;\n    }\n    let /** @type {?} */ compileMethod = view.detectChangesRenderPropertiesMethod;\n    switch (boundProp.type) {\n      case PropertyBindingType.Property:\n      case PropertyBindingType.Attribute:\n      case PropertyBindingType.Class:\n      case PropertyBindingType.Style:\n        compileMethod.addStmts(createCheckRenderBindingStmt(\n            o.THIS_EXPR, renderNode, boundProp, bindingField.expression, evalResult));\n        break;\n      case PropertyBindingType.Animation:\n        compileMethod = view.animationBindingsMethod;\n        const {checkUpdateStmts, checkDetachStmts} = createCheckAnimationBindingStmts(\n            o.THIS_EXPR, o.THIS_EXPR, boundProp, boundOutputs,\n            (hasEvents ? o.THIS_EXPR.prop(getHandleEventMethodName(compileElement.nodeIndex)) :\n                         o.importExpr(createIdentifier(Identifiers.noop)))\n                .callMethod(o.BuiltinMethod.Bind, [o.THIS_EXPR]),\n            compileElement.renderNode, bindingField.expression, evalResult);\n        view.detachMethod.addStmts(checkDetachStmts);\n        compileMethod.addStmts(checkUpdateStmts);\n        break;\n    }\n  });\n}\n/**\n * @param {?} directiveAst\n * @param {?} directiveWrapperInstance\n * @param {?} compileElement\n * @param {?} elementName\n * @param {?} schemaRegistry\n * @return {?}\n */\nexport function bindDirectiveHostProps(\n    directiveAst: DirectiveAst, directiveWrapperInstance: o.Expression,\n    compileElement: CompileElement, elementName: string,\n    schemaRegistry: ElementSchemaRegistry): void {\n  // We need to provide the SecurityContext for properties that could need sanitization.\n  const /** @type {?} */ runtimeSecurityCtxExprs =\n      directiveAst.hostProperties.filter(boundProp => boundProp.needsRuntimeSecurityContext)\n          .map((boundProp) => {\n            let /** @type {?} */ ctx: SecurityContext;\n            switch (boundProp.type) {\n              case PropertyBindingType.Property:\n                ctx = schemaRegistry.securityContext(elementName, boundProp.name, false);\n                break;\n              case PropertyBindingType.Attribute:\n                ctx = schemaRegistry.securityContext(elementName, boundProp.name, true);\n                break;\n              default:\n                throw new Error(\n                    `Illegal state: Only property / attribute bindings can have an unknown security context! Binding ${boundProp.name}`);\n            }\n            return createEnumExpression(Identifiers.SecurityContext, ctx);\n          });\n  compileElement.view.detectChangesRenderPropertiesMethod.addStmts(\n      DirectiveWrapperExpressions.checkHost(\n          directiveAst.hostProperties, directiveWrapperInstance, o.THIS_EXPR,\n          compileElement.compViewExpr || o.THIS_EXPR, compileElement.renderNode,\n          runtimeSecurityCtxExprs));\n}\n/**\n * @param {?} directiveAst\n * @param {?} directiveWrapperInstance\n * @param {?} dirIndex\n * @param {?} compileElement\n * @return {?}\n */\nexport function bindDirectiveInputs(\n    directiveAst: DirectiveAst, directiveWrapperInstance: o.Expression, dirIndex: number,\n    compileElement: CompileElement) {\n  const /** @type {?} */ view = compileElement.view;\n  const /** @type {?} */ detectChangesInInputsMethod = view.detectChangesInInputsMethod;\n  detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n\n  directiveAst.inputs.forEach((input, inputIdx) => {\n    // Note: We can't use `fields.length` here, as we are not adding a field!\n    const /** @type {?} */ bindingId = `${compileElement.nodeIndex}_${dirIndex}_${inputIdx}`;\n    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);\n    const /** @type {?} */ evalResult =\n        convertPropertyBinding(view, view, view.componentContext, input.value, bindingId);\n    if (!evalResult) {\n      return;\n    }\n    detectChangesInInputsMethod.addStmts(evalResult.stmts);\n    detectChangesInInputsMethod.addStmt(\n        directiveWrapperInstance\n            .callMethod(\n                `check_${input.directiveName}`,\n                [o.THIS_EXPR, evalResult.currValExpr, evalResult.forceUpdate || o.literal(false)])\n            .toStmt());\n  });\n  const /** @type {?} */ isOnPushComp = directiveAst.directive.isComponent &&\n      !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);\n  const /** @type {?} */ directiveDetectChangesExpr = DirectiveWrapperExpressions.ngDoCheck(\n      directiveWrapperInstance, o.THIS_EXPR, compileElement.renderNode);\n  const /** @type {?} */ directiveDetectChangesStmt = isOnPushComp ?\n      new o.IfStmt(\n          directiveDetectChangesExpr,\n          [compileElement.compViewExpr.callMethod('markAsCheckOnce', []).toStmt()]) :\n      directiveDetectChangesExpr.toStmt();\n  detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);\n}\n"]}