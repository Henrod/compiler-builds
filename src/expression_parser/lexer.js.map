{"version":3,"sources":["../../../../../modules/@angular/compiler/src/expression_parser/lexer.ts"],"names":[],"mappings":"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","file":"lexer.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {NumberWrapper} from '../facade/lang';\nimport {CompilerInjectable} from '../injectable';\nexport type TokenType = number;\nexport let TokenType: any = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\n\n\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n@CompilerInjectable()\nexport class Lexer {\n/**\n * @param {?} text\n * @return {?}\n */\ntokenize(text: string): Token[] {\n    const /** @type {?} */ scanner = new _Scanner(text);\n    const /** @type {?} */ tokens: Token[] = [];\n    let /** @type {?} */ token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\nexport class Token {\n/**\n * @param {?} index\n * @param {?} type\n * @param {?} numValue\n * @param {?} strValue\n */\nconstructor(\npublic index: number,\npublic type: TokenType,\npublic numValue: number,\npublic strValue: string) {}\n/**\n * @param {?} code\n * @return {?}\n */\nisCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n/**\n * @return {?}\n */\nisNumber(): boolean { return this.type == TokenType.Number; }\n/**\n * @return {?}\n */\nisString(): boolean { return this.type == TokenType.String; }\n/**\n * @param {?} operater\n * @return {?}\n */\nisOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n/**\n * @return {?}\n */\nisIdentifier(): boolean { return this.type == TokenType.Identifier; }\n/**\n * @return {?}\n */\nisKeyword(): boolean { return this.type == TokenType.Keyword; }\n/**\n * @return {?}\n */\nisKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n/**\n * @return {?}\n */\nisKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n/**\n * @return {?}\n */\nisKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n/**\n * @return {?}\n */\nisKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n/**\n * @return {?}\n */\nisKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n/**\n * @return {?}\n */\nisKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n/**\n * @return {?}\n */\nisError(): boolean { return this.type == TokenType.Error; }\n/**\n * @return {?}\n */\ntoNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n/**\n * @return {?}\n */\ntoString(): string {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction Token_tsickle_Closure_declarations() {\n/** @type {?} */\nToken.prototype.index;\n/** @type {?} */\nToken.prototype.type;\n/** @type {?} */\nToken.prototype.numValue;\n/** @type {?} */\nToken.prototype.strValue;\n}\n\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const /** @type {?} */ EOF: Token = new Token(-1, TokenType.Character, 0, '');\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n/**\n * @param {?} input\n */\nconstructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n/**\n * @return {?}\n */\nadvance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n/**\n * @return {?}\n */\nscanToken(): Token {\n    const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n    let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const /** @type {?} */ start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n/**\n * @param {?} start\n * @param {?} code\n * @return {?}\n */\nscanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n/**\n * @param {?} start\n * @param {?} str\n * @return {?}\n */\nscanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n/**\n * Tokenize a 2/3 char long operator\n * \n * @param {?} start start index in the expression\n * @param {?} one first symbol (always part of the operator)\n * @param {?} twoCode code point for the second symbol\n * @param {?} two second symbol (part of the operator when the second code point matches)\n * @param {?=} threeCode code point for the third symbol\n * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n * @return {?}\n */\nscanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let /** @type {?} */ str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n/**\n * @return {?}\n */\nscanIdentifier(): Token {\n    const /** @type {?} */ start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n                                        newIdentifierToken(start, str);\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nscanNumber(start: number): Token {\n    let /** @type {?} */ simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    const /** @type {?} */ value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n/**\n * @return {?}\n */\nscanString(): Token {\n    const /** @type {?} */ start: number = this.index;\n    const /** @type {?} */ quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let /** @type {?} */ buffer: string = '';\n    let /** @type {?} */ marker: number = this.index;\n    const /** @type {?} */ input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let /** @type {?} */ unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const /** @type {?} */ hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let /** @type {?} */ i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const /** @type {?} */ last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n/**\n * @param {?} message\n * @param {?} offset\n * @return {?}\n */\nerror(message: string, offset: number): Token {\n    const /** @type {?} */ position: number = this.index + offset;\n    return newErrorToken(\n        position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction _Scanner_tsickle_Closure_declarations() {\n/** @type {?} */\n_Scanner.prototype.length;\n/** @type {?} */\n_Scanner.prototype.peek;\n/** @type {?} */\n_Scanner.prototype.index;\n/** @type {?} */\n_Scanner.prototype.input;\n}\n\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const /** @type {?} */ scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n"]}