{"version":3,"sources":["../../../../../modules/@angular/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\nimport {CompilerInjectable} from '../injectable';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\nexport class SplitInterpolation {\n/**\n * @param {?} strings\n * @param {?} expressions\n * @param {?} offsets\n */\nconstructor(public strings: string[],\npublic expressions: string[],\npublic offsets: number[]) {}\n}\n\nfunction SplitInterpolation_tsickle_Closure_declarations() {\n/** @type {?} */\nSplitInterpolation.prototype.strings;\n/** @type {?} */\nSplitInterpolation.prototype.expressions;\n/** @type {?} */\nSplitInterpolation.prototype.offsets;\n}\n\nexport class TemplateBindingParseResult {\n/**\n * @param {?} templateBindings\n * @param {?} warnings\n * @param {?} errors\n */\nconstructor(\npublic templateBindings: TemplateBinding[],\npublic warnings: string[],\npublic errors: ParserError[]) {}\n}\n\nfunction TemplateBindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nTemplateBindingParseResult.prototype.templateBindings;\n/** @type {?} */\nTemplateBindingParseResult.prototype.warnings;\n/** @type {?} */\nTemplateBindingParseResult.prototype.errors;\n}\n\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\n@CompilerInjectable()\nexport class Parser {\nprivate errors: ParserError[] = [];\n/**\n * @param {?} _lexer\n */\nconstructor(private _lexer: Lexer) {}\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseAction(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const /** @type {?} */ sourceToLex = this._stripComments(input);\n    const /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n    const /** @type {?} */ ast = new _ParseAST(\n                    input, location, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseBinding(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseSimpleBinding(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n    const /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} message\n * @param {?} input\n * @param {?} errLocation\n * @param {?=} ctxLocation\n * @return {?}\n */\nprivate _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} interpolationConfig\n * @return {?}\n */\nprivate _parseBindingAst(\n      input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const /** @type {?} */ quote = this._parseQuote(input, location);\n\n    if (isPresent(quote)) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const /** @type {?} */ sourceToLex = this._stripComments(input);\n    const /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\nprivate _parseQuote(input: string, location: any): AST {\n    if (isBlank(input)) return null;\n    const /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n/**\n * @param {?} prefixToken\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\nparseTemplateBindings(prefixToken: string, input: string, location: any):\n      TemplateBindingParseResult {\n    const /** @type {?} */ tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n        .parseTemplateBindings();\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseInterpolation(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split == null) return null;\n\n    const /** @type {?} */ expressions: AST[] = [];\n\n    for (let /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n      const /** @type {?} */ expressionText = split.expressions[i];\n      const /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n      const /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n      const /** @type {?} */ ast = new _ParseAST(\n                      input, location, tokens, sourceToLex.length, false, this.errors,\n                      split.offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n        new Interpolation(\n            new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\n        input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nsplitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n    const /** @type {?} */ parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const /** @type {?} */ strings: string[] = [];\n    const /** @type {?} */ expressions: string[] = [];\n    const /** @type {?} */ offsets: number[] = [];\n    let /** @type {?} */ offset = 0;\n    for (let /** @type {?} */ i = 0; i < parts.length; i++) {\n      const /** @type {?} */ part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n            'Blank expressions are not allowed in interpolated strings', input,\n            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n            location);\n        expressions.push('$implict');\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\nwrapLiteralPrimitive(input: string, location: any): ASTWithSource {\n    return new ASTWithSource(\n        new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\n        location, this.errors);\n  }\n/**\n * @param {?} input\n * @return {?}\n */\nprivate _stripComments(input: string): string {\n    const /** @type {?} */ i = this._commentStart(input);\n    return isPresent(i) ? input.substring(0, i).trim() : input;\n  }\n/**\n * @param {?} input\n * @return {?}\n */\nprivate _commentStart(input: string): number {\n    let /** @type {?} */ outerQuote: number = null;\n    for (let /** @type {?} */ i = 0; i < input.length - 1; i++) {\n      const /** @type {?} */ char = input.charCodeAt(i);\n      const /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (isBlank(outerQuote) && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} interpolationConfig\n * @return {?}\n */\nprivate _checkNoInterpolation(\n      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n    const /** @type {?} */ parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n          `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n          location);\n    }\n  }\n/**\n * @param {?} parts\n * @param {?} partInErrIdx\n * @param {?} interpolationConfig\n * @return {?}\n */\nprivate _findInterpolationErrorColumn(\n      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n    let /** @type {?} */ errLocation = '';\n    for (let /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ?\n          parts[j] :\n          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nfunction Parser_tsickle_Closure_declarations() {\n/** @type {?} */\nParser.prototype.errors;\n/** @type {?} */\nParser.prototype._lexer;\n}\n\nexport class _ParseAST {\nprivate rparensExpected = 0;\nprivate rbracketsExpected = 0;\nprivate rbracesExpected = 0;\n\n  index: number = 0;\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} tokens\n * @param {?} inputLength\n * @param {?} parseAction\n * @param {?} errors\n * @param {?} offset\n */\nconstructor(\npublic input: string,\npublic location: any,\npublic tokens: Token[],\npublic inputLength: number,\npublic parseAction: boolean,\nprivate errors: ParserError[],\nprivate offset: number) {}\n/**\n * @param {?} offset\n * @return {?}\n */\npeek(offset: number): Token {\n    const /** @type {?} */ i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n/**\n * @return {?}\n */\nget next(): Token { return this.peek(0); }\n/**\n * @return {?}\n */\nget inputIndex(): number {\n    return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                                               this.inputLength + this.offset;\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nspan(start: number) { return new ParseSpan(start, this.inputIndex); }\n/**\n * @return {?}\n */\nadvance() { this.index++; }\n/**\n * @param {?} code\n * @return {?}\n */\noptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n/**\n * @return {?}\n */\npeekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n/**\n * @param {?} code\n * @return {?}\n */\nexpectCharacter(code: number) {\n    if (this.optionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n/**\n * @param {?} op\n * @return {?}\n */\noptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n/**\n * @param {?} operator\n * @return {?}\n */\nexpectOperator(operator: string) {\n    if (this.optionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n/**\n * @return {?}\n */\nexpectIdentifierOrKeyword(): string {\n    const /** @type {?} */ n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n/**\n * @return {?}\n */\nexpectIdentifierOrKeywordOrString(): string {\n    const /** @type {?} */ n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n/**\n * @return {?}\n */\nparseChain(): AST {\n    const /** @type {?} */ exprs: AST[] = [];\n    const /** @type {?} */ start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const /** @type {?} */ expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) return new EmptyExpr(this.span(start));\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), exprs);\n  }\n/**\n * @return {?}\n */\nparsePipe(): AST {\n    let /** @type {?} */ result = this.parseExpression();\n    if (this.optionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const /** @type {?} */ name = this.expectIdentifierOrKeyword();\n        const /** @type {?} */ args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator('|'));\n    }\n\n    return result;\n  }\n/**\n * @return {?}\n */\nparseExpression(): AST { return this.parseConditional(); }\n/**\n * @return {?}\n */\nparseConditional(): AST {\n    const /** @type {?} */ start = this.inputIndex;\n    const /** @type {?} */ result = this.parseLogicalOr();\n\n    if (this.optionalOperator('?')) {\n      const /** @type {?} */ yes = this.parsePipe();\n      let /** @type {?} */ no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const /** @type {?} */ end = this.inputIndex;\n        const /** @type {?} */ expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n/**\n * @return {?}\n */\nparseLogicalOr(): AST {\n    // '||'\n    let /** @type {?} */ result = this.parseLogicalAnd();\n    while (this.optionalOperator('||')) {\n      const /** @type {?} */ right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), '||', result, right);\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseLogicalAnd(): AST {\n    // '&&'\n    let /** @type {?} */ result = this.parseEquality();\n    while (this.optionalOperator('&&')) {\n      const /** @type {?} */ right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), '&&', result, right);\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseEquality(): AST {\n    // '==','!=','===','!=='\n    let /** @type {?} */ result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const /** @type {?} */ right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let /** @type {?} */ result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const /** @type {?} */ right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseAdditive(): AST {\n    // '+', '-'\n    let /** @type {?} */ result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let /** @type {?} */ right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseMultiplicative(): AST {\n    // '*', '%', '/'\n    let /** @type {?} */ result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let /** @type {?} */ right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ start = this.inputIndex;\n      const /** @type {?} */ operator = this.next.strValue;\n      let /** @type {?} */ result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          return this.parsePrefix();\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n              result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n/**\n * @return {?}\n */\nparseCallChain(): AST {\n    let /** @type {?} */ result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n\n      } else if (this.optionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const /** @type {?} */ key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator('=')) {\n          const /** @type {?} */ value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const /** @type {?} */ args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n\n      } else {\n        return result;\n      }\n    }\n  }\n/**\n * @return {?}\n */\nparsePrimary(): AST {\n    const /** @type {?} */ start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const /** @type {?} */ result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const /** @type {?} */ elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n    } else if (this.next.isNumber()) {\n      const /** @type {?} */ value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n\n    } else if (this.next.isString()) {\n      const /** @type {?} */ literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n/**\n * @param {?} terminator\n * @return {?}\n */\nparseExpressionList(terminator: number): AST[] {\n    const /** @type {?} */ result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseLiteralMap(): LiteralMap {\n    const /** @type {?} */ keys: string[] = [];\n    const /** @type {?} */ values: AST[] = [];\n    const /** @type {?} */ start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n        keys.push(key);\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n/**\n * @param {?} receiver\n * @param {?=} isSafe\n * @return {?}\n */\nparseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n    const /** @type {?} */ start = receiver.span.start;\n    const /** @type {?} */ id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const /** @type {?} */ args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const /** @type {?} */ span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                      new MethodCall(span, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start));\n          }\n\n          const /** @type {?} */ value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n/**\n * @return {?}\n */\nparseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const /** @type {?} */ positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return /** @type {?} */(( positionals as BindingPipe[]));\n  }\n/**\n * An identifier, a keyword, a string with an optional `-` inbetween.\n * @return {?}\n */\nexpectTemplateBindingKey(): string {\n    let /** @type {?} */ result = '';\n    let /** @type {?} */ operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n/**\n * @return {?}\n */\nparseTemplateBindings(): TemplateBindingParseResult {\n    const /** @type {?} */ bindings: TemplateBinding[] = [];\n    let /** @type {?} */ prefix: string = null;\n    const /** @type {?} */ warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const /** @type {?} */ start = this.inputIndex;\n      const /** @type {?} */ keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      let /** @type {?} */ key = this.expectTemplateBindingKey();\n      if (!keyIsVar) {\n        if (prefix == null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let /** @type {?} */ name: string = null;\n      let /** @type {?} */ expression: ASTWithSource = null;\n      if (keyIsVar) {\n        if (this.optionalOperator('=')) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = '\\$implicit';\n        }\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const /** @type {?} */ start = this.inputIndex;\n        const /** @type {?} */ ast = this.parsePipe();\n        const /** @type {?} */ source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n/**\n * @param {?} message\n * @param {?=} index\n * @return {?}\n */\nerror(message: string, index: number = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\nprivate locationText(index: number = null) {\n    if (isBlank(index)) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n/**\n * @return {?}\n */\nprivate skip() {\n    let /** @type {?} */ n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nfunction _ParseAST_tsickle_Closure_declarations() {\n/** @type {?} */\n_ParseAST.prototype.rparensExpected;\n/** @type {?} */\n_ParseAST.prototype.rbracketsExpected;\n/** @type {?} */\n_ParseAST.prototype.rbracesExpected;\n/** @type {?} */\n_ParseAST.prototype.index;\n/** @type {?} */\n_ParseAST.prototype.input;\n/** @type {?} */\n_ParseAST.prototype.location;\n/** @type {?} */\n_ParseAST.prototype.tokens;\n/** @type {?} */\n_ParseAST.prototype.inputLength;\n/** @type {?} */\n_ParseAST.prototype.parseAction;\n/** @type {?} */\n_ParseAST.prototype.errors;\n/** @type {?} */\n_ParseAST.prototype.offset;\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n/**\n * @param {?} ast\n * @return {?}\n */\nstatic check(ast: AST): string[] {\n    const /** @type {?} */ s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitInterpolation(ast: Interpolation, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPropertyRead(ast: PropertyRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPropertyWrite(ast: PropertyWrite, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitMethodCall(ast: MethodCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitFunctionCall(ast: FunctionCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitBinary(ast: Binary, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPrefixNot(ast: PrefixNot, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitConditional(ast: Conditional, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyedRead(ast: KeyedRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyedWrite(ast: KeyedWrite, context: any) {}\n/**\n * @param {?} asts\n * @return {?}\n */\nvisitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitChain(ast: Chain, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitQuote(ast: Quote, context: any) {}\n}\n\nfunction SimpleExpressionChecker_tsickle_Closure_declarations() {\n/** @type {?} */\nSimpleExpressionChecker.prototype.errors;\n}\n\n"]}