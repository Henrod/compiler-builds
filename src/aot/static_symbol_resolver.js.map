{"version":3,"sources":["../../../../../modules/@angular/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","file":"static_symbol_resolver.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isNgFactoryFile} from './util';\nexport class ResolvedStaticSymbol {\n/**\n * @param {?} symbol\n * @param {?} metadata\n */\nconstructor(public symbol: StaticSymbol,\npublic metadata: any) {}\n}\n\nfunction ResolvedStaticSymbol_tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedStaticSymbol.prototype.symbol;\n/** @type {?} */\nResolvedStaticSymbol.prototype.metadata;\n}\n\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[];\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile: string): string /*|null*/;\n}\n\nconst /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n * \n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\nprivate metadataCache = new Map<string, {[key: string]: any}>();\nprivate resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\nprivate resolvedFilePaths = new Set<string>();\nprivate importAs = new Map<StaticSymbol, StaticSymbol>();\n/**\n * @param {?} host\n * @param {?} staticSymbolCache\n * @param {?} summaryResolver\n * @param {?=} errorRecorder\n */\nconstructor(\nprivate host: StaticSymbolResolverHost,\nprivate staticSymbolCache: StaticSymbolCache,\nprivate summaryResolver: SummaryResolver<StaticSymbol>,\nprivate errorRecorder?: (error: any, fileName: string) => void) {}\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nresolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol);\n    }\n    let /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n    if (result) {\n      return result;\n    }\n    result = this._resolveSymbolFromSummary(staticSymbol);\n    if (result) {\n      return result;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    result = this.resolvedSymbols.get(staticSymbol);\n    return result;\n  }\n/**\n * getImportAs produces a symbol that can be used to import the given symbol.\n * The import might be different than the symbol if the symbol is exported from\n * a library with a summary; in which case we want to import the symbol from the\n * ngfactory re-export instead of directly to avoid introducing a direct dependency\n * on an otherwise indirect dependency.\n * \n * @param {?} staticSymbol the symbol for which to generate a import symbol\n * @return {?}\n */\ngetImportAs(staticSymbol: StaticSymbol): StaticSymbol {\n    if (staticSymbol.members.length) {\n      const /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    let /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n    if (!result) {\n      result = this.importAs.get(staticSymbol);\n    }\n    return result;\n  }\n/**\n * getTypeArity returns the number of generic type parameters the given symbol\n * has. If the symbol is not a type the result is null.\n * @param {?} staticSymbol\n * @return {?}\n */\ngetTypeArity(staticSymbol: StaticSymbol): number /*|null*/ {\n    // If the file is a factory file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isNgFactoryFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ members = staticSymbol.members;\n    const /** @type {?} */ baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    const /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let /** @type {?} */ value = baseMetadata;\n      for (let /** @type {?} */ i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nprivate _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    const /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n/**\n * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n * All types passed to the StaticResolver should be pseudo-types returned by this method.\n * \n * @param {?} declarationFile the absolute path of the file where the symbol is declared\n * @param {?} name the name of the type.\n * @param {?=} members a symbol for a static member of the named type\n * @return {?}\n */\ngetStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\ngetSymbolsOf(filePath: string): StaticSymbol[] {\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    let /** @type {?} */ symbols = new Set<StaticSymbol>(this.summaryResolver.getSymbolsOf(filePath));\n    this._createSymbolsOf(filePath);\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        symbols.add(resolvedSymbol.symbol);\n      }\n    });\n    return Array.from(symbols);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\nprivate _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const /** @type {?} */ resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const /** @type {?} */ topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n        resolvedSymbols.push(this.createResolvedSymbol(\n            this.getStaticSymbol(filePath, unescapeIdentifier(metadataKey)), topLevelSymbolNames,\n            symbolMeta));\n      });\n    }\n\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const /** @type {?} */ moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let /** @type {?} */ symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let /** @type {?} */ symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const /** @type {?} */ targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const /** @type {?} */ nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} topLevelSymbolNames\n * @param {?} metadata\n * @return {?}\n */\nprivate createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    const /** @type {?} */ self = this;\nclass ReferenceTransformer extends ValueTransformer {\n/**\n * @param {?} map\n * @param {?} functionParams\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const /** @type {?} */ symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const /** @type {?} */ oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const /** @type {?} */ result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const /** @type {?} */ module = map['module'];\n          const /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let /** @type {?} */ filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath);\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`\n              };\n            }\n            return self.getStaticSymbol(filePath, name);\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(sourceSymbol.filePath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    if (transformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, transformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} targetSymbol\n * @return {?}\n */\nprivate createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n/**\n * @param {?} error\n * @param {?} context\n * @param {?=} path\n * @return {?}\n */\nprivate reportError(error: Error, context: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n/**\n * @param {?} module an absolute path to a module file.\n * @return {?}\n */\nprivate getModuleMetadata(module: string): {[key: string]: any} {\n    let /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let /** @type {?} */ maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage), null);\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n/**\n * @param {?} module\n * @param {?} symbolName\n * @param {?=} containingFile\n * @return {?}\n */\ngetSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ` relative to $ {\n            containingFile\n          } `: ''}`),\n          null);\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n/**\n * @param {?} module\n * @param {?} containingFile\n * @return {?}\n */\nprivate resolveModule(module: string, containingFile: string): string {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch ( /** @type {?} */e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(new e, null, containingFile);\n    }\n  }\n}\n\nfunction StaticSymbolResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nStaticSymbolResolver.prototype.metadataCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedSymbols;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedFilePaths;\n/** @type {?} */\nStaticSymbolResolver.prototype.importAs;\n/** @type {?} */\nStaticSymbolResolver.prototype.host;\n/** @type {?} */\nStaticSymbolResolver.prototype.staticSymbolCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.summaryResolver;\n/** @type {?} */\nStaticSymbolResolver.prototype.errorRecorder;\n}\n\n/**\n * @param {?} identifier\n * @return {?}\n */\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}"]}